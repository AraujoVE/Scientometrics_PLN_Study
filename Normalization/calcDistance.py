import os
import matplotlib.pyplot as plt
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np
import matplotlib.patches as mpatches

'''
The embeddings of just the chosen strings remain, and for each area
a matrix is generated by the cosine similarity of the embeddings of the chosen strings.
the same process of converting a nxn matriz into a ((nÂ²-n)/2) vector done in ic1 is done here.
Then, a plot for each pair of chosen strings is generated. In each plot,
a bar is created for each area
'''


def getEmbedding(path,keyStr):
    with open(path,"r") as f:
        lines = f.readlines()
        embSize = int(lines[0].strip().split()[1])
        linesDict = dict([(i.strip().split()[0],i) for i in lines[1:]])
    keyStrEmb = {}
    emptyKeys = []

    for i in keyStr:
        if i not in linesDict.keys():
            keyStrEmb[i] = np.zeros(embSize)
            emptyKeys.append(i)
        else:
            keyStrEmb[i] = np.array([float(j) for j in linesDict[i].strip().split()[1:]])        

    
    return emptyKeys, np.array([keyStrEmb[keyStr[i]] for i in range(len(keyStr))])

def reducedCossineSim(emb,keyStrs,emptyKeys):
    cosSim = np.array(cosine_similarity(emb))
    redCosSim = []
    for i in range(len(keyStrs) - 1):
        for j in range(i + 1, len(keyStrs)):
            if i in emptyKeys or j in emptyKeys:
                redCosSim.append(np.nan)
                print("nan value")
            else:
                redCosSim.append(cosSim[i,j])

    return np.array(redCosSim)

def getSimilarityEmbedding(path,keyStrs):
    emptyKeys, emb = getEmbedding(path,keyStrs)
    return reducedCossineSim(emb,keyStrs,emptyKeys)

def showAndSaveData(emb,keyStrPairs,dirs,strPairsDiv):
    barNames = [i.replace("_"," ") for i in dirs]
    y_pos = np.arange(len(barNames))
    heights = [[emb[dirs[j]][i] for j in range(len(dirs))] for i in range(len(keyStrPairs))]

    for i in range(len(keyStrPairs)):
        fig, ax = plt.subplots()
        # Create bars
        ax.bar(y_pos, heights[i],color="b")

        # Create names on the x-axis
        plt.xticks(y_pos, barNames)

        #ticklabels = plt.gca().get_xticklabels()

        # Set xtick to red if value is equal to np.nan, black otherwise
        '''
        for t in range(len(ticklabels)):
            ticklabels[t].set_color('r' if np.isnan(heights[i][t]) else 'b')
        '''


        #blue_patch = mpatches.Patch(color='blue', label='Existent Similarity')
        #red_patch = mpatches.Patch(color='red', label='Non-Existent Similarity')

        #plt.legend(handles=[red_patch, blue_patch])# Set xtick to red if value is equal to np.nan, black otherwise

        strs = keyStrPairs[i].split(strPairsDiv)
        # Add title
        plt.title("Cossine similarity between "+strs[0]+" and "+strs[1])
        ax.xaxis.set_tick_params(rotation=90)

        plt.gcf().subplots_adjust(bottom=0.45)
        # Show graphic
        fig.savefig("./figs/img_"+str(keyStrPairs[i])+".png")
        plt.close(fig)




def main():
    keyStrsDistanceEmbeddings = {}
    keyStrs = [i for i in open("./ChoosenStrs/Normalized/specialStrs.txt","r").read().strip().split()]
    keyStrPairs = []
    strPairsDiv = "_x_"
    for i in range(len(keyStrs)-1):
        for j in range(i+1,len(keyStrs)):
            keyStrPairs.append(keyStrs[i]+strPairsDiv+keyStrs[j])
    
    dirs = [i for i in os.listdir("./Texts") if os.path.isdir("./Texts/"+i)]

    for i in range(len(dirs)):
        keyStrsDistanceEmbeddings[dirs[i]] = getSimilarityEmbedding("./Texts/"+dirs[i]+"/Normalized/node2vec.txt",keyStrs)
    
    showAndSaveData(keyStrsDistanceEmbeddings,keyStrPairs,dirs,strPairsDiv)




main()